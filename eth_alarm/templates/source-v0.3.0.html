{% extends "layout_source.html" %}

{% block tab_020_class %}active{% endblock %}

{% block contract_address %}0xdb15058402c241b04a03846f6fb104b1fbeea10b{% endblock %}

{% block instructions %}
    <div class="page-header">
        <h1>Verifying the Source Code</h1>
    </div>
    <p>The full source code for the Alarm service can be found below.
    I highly encourage you to compile it and verify that the code for
    advertised contract address matches the the output of the compiled
    contract below.</p>

    <p>The sha256 of the source is
    <code>5e1f16f25ca4aa77cc6b7b5232653a3308b3a0fc375135752f86bbc773878f2c</code></p>

    <p>If you copy/paste the source code below you may get additional white
    space.  Ensure that there are no leading linebreaks, and that the code ends
    with the final closing brace of the <code>Alarm</code> contract followed by
    a newline.</p>

    <p>Alternatively, you can use the published
    <a href="https://github.com/pipermerriam/ethereum-alarm-clock/releases/tag/v0.3.0" target="_blank">0.3.0 release on github</a></p>

    <p>To verify the compiled code of the contract, you will need to
    compile the source below with the solc compiler.  You will likely need
    to use the same version used when deploying the contract,
    <code>Version: 0.1.3-1736fe80/RelWithDebInfo-Darwin/unknown/JIT linked to libethereum-0.9.92-dcf2fd11/RelWithDebInfo-Darwin/unknown/JIT</code></p>

    <p>This version of solc was compiled using the <a href="https://github.com/ethereum/webthree-helpers" target="_blank">webthree-helpers repository</a> at commit <code>7d1941c6acb4d886c51052c9d25601d62443e610</code> and the <a href="" target="_blank">solidity github repository</a> at commit <code>1736fe801591085534798fa40b347bab6f471cb3</code>.

    <pre><code class="language-bash">$ solc --version
solc, the solidity compiler commandline interface
Version: 0.1.3-1736fe80/RelWithDebInfo-Darwin/unknown/JIT linked to libethereum-0.9.92-dcf2fd11/RelWithDebInfo-Darwin/unknown/JIT</pre></code>

    <p>The source was compiled with the command 
    <code>solc --optimize --bin --bin-runtime source.sol</code> where the
    source code is located in a file named </code>source.sol</code></p>

    <p>To verify the source you check that the bytecode associated with
    the Alarm service address equals the binary output from the solc compiler
    when using the <code>--bin-runtime</code> flag.</p>

    <p>If you would like to be extra thorough, you should also check the code
    of both the authorized Relay, unauthorized Relay, and CallerPool addresses
    (as returned by the alarm contract)</p>
{% endblock %}

{% block contract_source %}/*
 *  Version 0.3.0
 *
 *  address: 0xdb15058402c241b04a03846f6fb104b1fbeea10b
 */
contract Relay {
        address operator;

        function Relay() {
                operator = msg.sender;
        }

        function relayCall(address contractAddress, bytes4 abiSignature, bytes data) public returns (bool) {
                if (msg.sender != operator) {
                        __throw();
                }
                return contractAddress.call(abiSignature, data);
        }

        function __throw() internal {
                int[] x;
                x[1];
        }
}


contract CallerPool {
        address operator;

        function CallerPool() {
                operator = msg.sender;
        }

        /*
         *  Caller bonding
         */
        mapping (address => uint) public callerBonds;

        function getMinimumBond() constant returns (uint) {
                return tx.gasprice * block.gaslimit;
        }

        function _deductFromBond(address callerAddress, uint value) internal {
                /*
                 *  deduct funds from a bond value without risk of an
                 *  underflow.
                 */
                if (value > callerBonds[callerAddress]) {
                        // Prevent Underflow.
                        __throw();
                }
                callerBonds[callerAddress] -= value;
        }

        function _addToBond(address callerAddress, uint value) internal {
                /*
                 *  Add funds to a bond value without risk of an
                 *  overflow.
                 */
                if (callerBonds[callerAddress] + value < callerBonds[callerAddress]) {
                        // Prevent Overflow
                        __throw();
                }
                callerBonds[callerAddress] += value;
        }

        function depositBond() public {
                _addToBond(msg.sender, msg.value);
        }

        function withdrawBond(uint value) public {
                /*
                 *  Only if you are not in either of the current call pools.
                 */
                if (isInAnyPool(msg.sender)) {
                        // Prevent underflow
                        if (value > callerBonds[msg.sender]) {
                                __throw();
                        }
                        // Don't allow withdrawl if this would drop the bond
                        // balance below the minimum.
                        if (callerBonds[msg.sender] - value < getMinimumBond()) {
                                return;
                        }
                }
                _deductFromBond(msg.sender, value);
                if (!msg.sender.send(value)) {
                        // Potentially sending money to a contract that
                        // has a fallback function.  So instead, try
                        // tranferring the funds with the call api.
                        if (!msg.sender.call.gas(msg.gas).value(value)()) {
                                // Revert the entire transaction.  No
                                // need to destroy the funds.
                                __throw();
                        }
                }
        }

        function() {
                /*
                 *  Fallback function that allows depositing bond funds just by
                 *  sending a transaction.
                 */
                _addToBond(msg.sender, msg.value);
        }

        /*
         *  API used by Alarm service
         */
        function getDesignatedCaller(bytes32 callKey, uint targetBlock, uint8 gracePeriod, uint blockNumber) constant returns (address) {
                /*
                 *  Returns the caller from the current call pool who is
                 *  designated as the executor of this call.
                 */
                if (blockNumber < targetBlock || blockNumber > targetBlock + gracePeriod) {
                        // blockNumber not within call window.
                        return 0x0;
                }

                // Pool used is based on the starting block for the call.  This
                // allows us to know that the pool cannot change for at least
                // POOL_FREEZE_NUM_BLOCKS which is kept greater than the max
                // grace period.
                uint poolNumber = getPoolKeyForBlock(targetBlock);
                if (poolNumber == 0) {
                        // No pool currently in operation.
                        return 0x0;
                }
                var pool = callerPools[poolNumber];

                uint numWindows = gracePeriod / 4;
                uint blockWindow = (blockNumber - targetBlock) / 4;

                if (blockWindow + 2 > numWindows) {
                        // We are within the free-for-all period.
                        return 0x0;
                }

                uint offset = uint(callKey) % pool.length;
                return pool[(offset + blockWindow) % pool.length];
        }

        event AwardedMissedBlockBonus(address indexed fromCaller, address indexed toCaller, uint indexed poolNumber, bytes32 callKey, uint blockNumber, uint bonusAmount);

        function _doBondBonusTransfer(address fromCaller, address toCaller) internal returns (uint) {
                uint bonusAmount = getMinimumBond();
                uint bondBalance = callerBonds[fromCaller];

                // If the bond balance is lower than the award
                // balance, then adjust the reward amount to
                // match the bond balance.
                if (bonusAmount > bondBalance) {
                        bonusAmount = bondBalance;
                }

                // Transfer the funds fromCaller => toCaller
                _deductFromBond(fromCaller, bonusAmount);
                _addToBond(toCaller, bonusAmount);

                return bonusAmount;
        }

        function awardMissedBlockBonus(address toCaller, bytes32 callKey, uint targetBlock, uint8 gracePeriod) public {
                if (msg.sender != operator) {
                        return;
                }

                uint poolNumber = getPoolKeyForBlock(targetBlock);
                var pool = callerPools[poolNumber];
                uint i;
                uint bonusAmount;
                address fromCaller;

                uint numWindows = gracePeriod / 4;
                uint blockWindow = (block.number - targetBlock) / 4;

                // Check if we are within the free-for-all period.  If so, we
                // award from all pool members.
                if (blockWindow + 2 > numWindows) {
                        address firstCaller = getDesignatedCaller(callKey, targetBlock, gracePeriod, targetBlock);
                        for (i = targetBlock; i <= targetBlock + gracePeriod; i += 4) {
                                fromCaller = getDesignatedCaller(callKey, targetBlock, gracePeriod, i);
                                if (fromCaller == firstCaller && i != targetBlock) {
                                        // We have already gone through all of
                                        // the pool callers so we should break
                                        // out of the loop.
                                        break;
                                }
                                if (fromCaller == toCaller) {
                                        continue;
                                }
                                bonusAmount = _doBondBonusTransfer(fromCaller, toCaller);

                                // Log the bonus was awarded.
                                AwardedMissedBlockBonus(fromCaller, toCaller, poolNumber, callKey, block.number, bonusAmount);
                        }
                        return;
                }

                // Special case for single member and empty pools
                if (pool.length < 2) {
                        return;
                }

                // Otherwise the award comes from the previous caller.
                for (i = 0; i < pool.length; i++) {
                        // Find where the member is in the pool and
                        // award from the previous pool members bond.
                        if (pool[i] == toCaller) {
                                fromCaller = pool[(i + pool.length - 1) % pool.length];

                                bonusAmount = _doBondBonusTransfer(fromCaller, toCaller);

                                // Log the bonus was awarded.
                                AwardedMissedBlockBonus(fromCaller, toCaller, poolNumber, callKey, block.number, bonusAmount);

                                // Remove the caller from the next pool.
                                if (getNextPoolKey() == 0) {
                                        // This is the first address to modify the
                                        // current pool so we need to setup the next
                                        // pool.
                                        _initiateNextPool();
                                }
                                _removeFromPool(fromCaller, getNextPoolKey());
                                return;
                        }
                }
        }

        /*
         *  Caller Pool Management
         */
        uint[] public poolHistory;
        mapping (uint => address[]) callerPools;

        function getPoolKeyForBlock(uint blockNumber) constant returns (uint) {
                if (poolHistory.length == 0) {
                        return 0;
                }
                for (uint i = 0; i < poolHistory.length; i++) {
                        uint poolStartBlock = poolHistory[poolHistory.length - i - 1];
                        if (poolStartBlock <= blockNumber) {
                                return poolStartBlock;
                        }
                }
                return 0;
        }

        function getActivePoolKey() constant returns (uint) {
                return getPoolKeyForBlock(block.number);
        }

        function getPoolSize(uint poolKey) constant returns (uint) {
                return callerPools[poolKey].length;
        }

        function getNextPoolKey() constant returns (uint) {
                if (poolHistory.length == 0) {
                        return 0;
                }
                uint latestPool = poolHistory[poolHistory.length - 1];
                if (latestPool > block.number) {
                        return latestPool;
                }
                return 0;
        }

        function isInAnyPool(address callerAddress) constant returns (bool) {
                /*
                 *  Returns boolean whether the `callerAddress` is in either
                 *  the current active pool or the next pool.
                 */
                return isInPool(msg.sender, getActivePoolKey()) || isInPool(msg.sender, getNextPoolKey());
        }

        function isInPool(address callerAddress, uint poolNumber) constant returns (bool) {
                /*
                 *  Returns boolean whether the `callerAddress` is in the
                 *  poolNumber.
                 */
                if (poolNumber == 0 ) {
                        // Nobody can be in pool 0
                        return false;
                }

                var pool = callerPools[poolNumber];

                // Nobody is in the pool.
                if (pool.length == 0) {
                        return false;
                }

                for (uint i = 0; i < pool.length; i++) {
                        // Address is in the pool and thus is allowed to exit.
                        if (pool[i] == callerAddress) {
                                return true;
                        }
                }

                return false;
        }

        // Ten minutes into the future.
        uint constant POOL_FREEZE_NUM_BLOCKS = 256;

        function getPoolFreezeDuration() constant returns (uint) {
                return POOL_FREEZE_NUM_BLOCKS;
        }

        function getPoolMinimumLength() constant returns (uint) {
                return 2 * POOL_FREEZE_NUM_BLOCKS;
        }

        function canEnterPool(address callerAddress) constant returns (bool) {
                /*
                 *  Returns boolean whether `callerAddress` is allowed to enter
                 *  the next pool (which may or may not already have been
                 *  created.
                 */
                // Not allowed to join if you are in either the current
                // active pool or the next pool.
                if (isInAnyPool(callerAddress)) {
                        return false;
                }

                // Next pool begins within the POOL_FREEZE_NUM_BLOCKS grace
                // period so no changes are allowed.
                if (getNextPoolKey() != 0 && block.number >= (getNextPoolKey() - POOL_FREEZE_NUM_BLOCKS)) {
                        return false;
                }

                // Account bond balance is too low.
                if (callerBonds[callerAddress] < getMinimumBond()) {
                        return false;
                }
                
                return true;
        }

        function canExitPool(address callerAddress) constant returns (bool) {
                /*
                 *  Returns boolean whether `callerAddress` is allowed to exit
                 *  the current active pool.
                 */
                // Can't exit if we aren't in the current active pool.
                if (!isInPool(callerAddress, getActivePoolKey())) {
                        return false;
                }

                // There is a next pool coming up.
                if (getNextPoolKey() != 0) {
                        // Next pool begins within the POOL_FREEZE_NUM_BLOCKS
                        // window and thus can't be modified.
                        if (block.number >= (getNextPoolKey() - POOL_FREEZE_NUM_BLOCKS)) {
                                return false;
                        }

                        // Next pool was already setup and callerAddress isn't
                        // in it which indicates that they already left.
                        if (!isInPool(callerAddress, getNextPoolKey())) {
                                return false;
                        }
                }

                // They must be in the current pool and either the next pool
                // hasn't been initiated or it has but this user hasn't left
                // yet.
                return true;
        }

        function _initiateNextPool() internal {
                if (getNextPoolKey() != 0) {
                        // If there is already a next pool, we shouldn't
                        // initiate a new one until it has become active.
                        __throw();
                }
                // Set the next pool to start at double the freeze block number
                // in the future.
                uint nextPool = block.number + 2 * POOL_FREEZE_NUM_BLOCKS;

                // Copy the current pool into the next pool.
                callerPools[nextPool] = callerPools[getActivePoolKey()];

                // Randomize the pool order
                _shufflePool(nextPool);

                // Push the next pool into the pool history.
                poolHistory.length += 1;
                poolHistory[poolHistory.length - 1] = nextPool;
        }

        function _shufflePool(uint poolNumber) internal {
                var pool = callerPools[poolNumber];

                uint swapIndex;
                address buffer;

                for (uint i = 0; i < pool.length; i++) {
                        swapIndex = uint(sha3(block.blockhash(block.number), i)) % pool.length;
                        if (swapIndex == i) {
                                continue;
                        }
                        buffer = pool[i];
                        pool[i] = pool[swapIndex];
                        pool[swapIndex] = buffer;
                }
        }

        event AddedToPool(address indexed callerAddress, uint indexed pool);
        event RemovedFromPool(address indexed callerAddress, uint indexed pool);

        function _addToPool(address callerAddress, uint poolNumber) internal {
                if (poolNumber == 0 ) {
                        // This shouldn't be called with 0;
                        __throw();
                }

                // already in the pool.
                if (isInPool(callerAddress, poolNumber)) {
                        return;
                }
                var pool = callerPools[poolNumber];
                pool.length += 1;
                pool[pool.length - 1] = callerAddress;
                
                // Log the addition.
                AddedToPool(callerAddress, poolNumber);
        }

        function _removeFromPool(address callerAddress, uint poolNumber) internal {
                if (poolNumber == 0 ) {
                        // This shouldn't be called with 0;
                        __throw();
                }

                // nothing to remove.
                if (!isInPool(callerAddress, poolNumber)) {
                        return;
                }
                var pool = callerPools[poolNumber];
                // special case length == 1
                if (pool.length == 1) {
                        pool.length = 0;
                }
                for (uint i = 0; i < pool.length; i++) {
                        // When we find the index of the address to remove we
                        // shift the last person to that location and then we
                        // truncate the last member off of the end.
                        if (pool[i] == callerAddress) {
                                pool[i] = pool[pool.length - 1];
                                pool.length -= 1;
                                break;
                        }
                }

                // Log the addition.
                RemovedFromPool(callerAddress, poolNumber);
        }

        function enterPool() public {
                /*
                 *  Request to be added to the call pool.
                 */
                if (canEnterPool(msg.sender)) {
                        if (getNextPoolKey() == 0) {
                                // This is the first address to modify the
                                // current pool so we need to setup the next
                                // pool.
                                _initiateNextPool();
                        }
                        _addToPool(msg.sender, getNextPoolKey());
                }
        }

        function exitPool() public {
                /*
                 *  Request to be removed from the call pool.
                 */
                if (canExitPool(msg.sender)) {
                        if (getNextPoolKey() == 0) {
                                // This is the first address to modify the
                                // current pool so we need to setup the next
                                // pool.
                                _initiateNextPool();
                        }
                        _removeFromPool(msg.sender, getNextPoolKey());
                }
        }

        function __throw() internal {
                int[] x;
                x[1];
        }
}


contract GroveAPI {
        function getIndexId(address ownerAddress, bytes32 indexName) constant returns (bytes32);
        function insert(bytes32 indexName, bytes32 id, int value) public;
}


contract Alarm {
        /*
         *  Administration API
         *
         *  There is currently no special administrative API beyond the hard
         *  coded owner address which receives 1% of each executed call.  This
         *  eliminates any need for trust as nobody has any special access.
         */
        function Alarm() {
                unauthorizedRelay = new Relay();
                authorizedRelay = new Relay();
                callerPool = new CallerPool();
        }

        address constant owner = 0xd3cda913deb6f67967b99d67acdfa1712c293601;

        // The deployed grove contract for call tree tracking.
        GroveAPI grove = GroveAPI(0xfe9d4e5717ec0e16f8301240df5c3f7d3e9effef);

        /*
         *  Account Management API
         */
        mapping (address => uint) public accountBalances;

        function _deductFunds(address accountAddress, uint value) internal {
                /*
                 *  Helper function that should be used for any reduction of
                 *  account funds.  It has error checking to prevent
                 *  underflowing the account balance which would be REALLY bad.
                 */
                if (value > accountBalances[accountAddress]) {
                        // Prevent Underflow.
                        __throw();
                }
                accountBalances[accountAddress] -= value;
        }

        function _addFunds(address accountAddress, uint value) internal {
                /*
                 *  Helper function that should be used for any addition of
                 *  account funds.  It has error checking to prevent
                 *  overflowing the account balance.
                 */
                if (accountBalances[accountAddress] + value < accountBalances[accountAddress]) {
                        // Prevent Overflow.
                        __throw();
                }
                accountBalances[accountAddress] += value;
        }

        event Deposit(address indexed _from, address indexed accountAddress, uint value);

        function deposit(address accountAddress) public {
                /*
                 *  Public API for depositing funds in a specified account.
                 */
                _addFunds(accountAddress, msg.value);
                Deposit(msg.sender, accountAddress, msg.value);
        }

        event Withdraw(address indexed accountAddress, uint value);

        function withdraw(uint value) public {
                /*
                 *  Public API for withdrawing funds.
                 */
                if (accountBalances[msg.sender] >= value) {
                        _deductFunds(msg.sender, value);
                        if (!msg.sender.send(value)) {
                                // Potentially sending money to a contract that
                                // has a fallback function.  So instead, try
                                // tranferring the funds with the call api.
                                if (!msg.sender.call.gas(msg.gas).value(value)()) {
                                        // Revert the entire transaction.  No
                                        // need to destroy the funds.
                                        __throw();
                                }
                        }
                        Withdraw(msg.sender, value);
                }
        }

        function() {
                /*
                 *  Fallback function that allows depositing funds just by
                 *  sending a transaction.
                 */
                _addFunds(msg.sender, msg.value);
                Deposit(msg.sender, msg.sender, msg.value);
        }

        /*
         *  Scheduling Authorization API
         */
        Relay unauthorizedRelay;
        Relay authorizedRelay;

        function unauthorizedAddress() constant returns (address) {
                return address(unauthorizedRelay);
        }

        function authorizedAddress() constant returns (address) {
                return address(authorizedRelay);
        }

        mapping (bytes32 => bool) accountAuthorizations;

        function addAuthorization(address schedulerAddress) public {
                accountAuthorizations[sha3(schedulerAddress, msg.sender)] = true;
        }

        function removeAuthorization(address schedulerAddress) public {
                accountAuthorizations[sha3(schedulerAddress, msg.sender)] = false;
        }

        function checkAuthorization(address schedulerAddress, address contractAddress) constant returns (bool) {
                return accountAuthorizations[sha3(schedulerAddress, contractAddress)];
        }

        /*
         *  Call Information API
         */
        bytes32 lastCallKey;

        function getLastCallKey() constant returns (bytes32) {
                return lastCallKey;
        }

        struct Call {
                address contractAddress;
                address scheduledBy;
                uint calledAtBlock;
                uint targetBlock;
                uint8 gracePeriod;
                uint nonce;
                uint baseGasPrice;
                uint gasPrice;
                uint gasUsed;
                uint gasCost;
                uint payout;
                uint fee;
                address executedBy;
                bytes4 abiSignature;
                bool isCancelled;
                bool wasCalled;
                bool wasSuccessful;
                bytes32 dataHash;
        }

        mapping (bytes32 => Call) key_to_calls;

        /*
         *  Getter methods for `Call` information
         */
        function getCallContractAddress(bytes32 callKey) constant returns (address) {
                return key_to_calls[callKey].contractAddress;
        }

        function getCallScheduledBy(bytes32 callKey) constant returns (address) {
                return key_to_calls[callKey].scheduledBy;
        }

        function getCallCalledAtBlock(bytes32 callKey) constant returns (uint) {
                return key_to_calls[callKey].calledAtBlock;
        }

        function getCallGracePeriod(bytes32 callKey) constant returns (uint) {
                return key_to_calls[callKey].gracePeriod;
        }

        function getCallTargetBlock(bytes32 callKey) constant returns (uint) {
                return key_to_calls[callKey].targetBlock;
        }

        function getCallBaseGasPrice(bytes32 callKey) constant returns (uint) {
                return key_to_calls[callKey].baseGasPrice;
        }

        function getCallGasPrice(bytes32 callKey) constant returns (uint) {
                return key_to_calls[callKey].gasPrice;
        }

        function getCallGasUsed(bytes32 callKey) constant returns (uint) {
                return key_to_calls[callKey].gasUsed;
        }

        function getCallABISignature(bytes32 callKey) constant returns (bytes4) {
                return key_to_calls[callKey].abiSignature;
        }

        function checkIfCalled(bytes32 callKey) constant returns (bool) {
                return key_to_calls[callKey].wasCalled;
        }

        function checkIfSuccess(bytes32 callKey) constant returns (bool) {
                return key_to_calls[callKey].wasSuccessful;
        }

        function checkIfCancelled(bytes32 callKey) constant returns (bool) {
                return key_to_calls[callKey].isCancelled;
        }

        function getCallDataHash(bytes32 callKey) constant returns (bytes32) {
                return key_to_calls[callKey].dataHash;
        }

        function getCallPayout(bytes32 callKey) constant returns (uint) {
                return key_to_calls[callKey].payout;
        }

        function getCallFee(bytes32 callKey) constant returns (uint) {
                return key_to_calls[callKey].fee;
        }

        /*
         *  Data Registry API
         */
        bytes lastData;
        uint lastDataLength;
        bytes32 lastDataHash;

        function getLastDataHash() constant returns (bytes32) {
                return lastDataHash;
        }

        function getLastDataLength() constant returns (uint) {
                return lastDataLength;
        }

        function getLastData() constant returns (bytes) {
                return lastData;
        }

        function getCallData(bytes32 callKey) constant returns (bytes) {
                return hash_to_data[key_to_calls[callKey].dataHash];
        }

        mapping (bytes32 => bytes) hash_to_data;

        /*
         *  Data registration API
         */
        //event DataRegistered(bytes32 indexed dataHash);

        function registerData() public {
                lastData.length = msg.data.length - 4;
                if (msg.data.length > 4) {
                        for (uint i = 0; i < lastData.length; i++) {
                                lastData[i] = msg.data[i + 4];
                        }
                }
                hash_to_data[sha3(lastData)] = lastData;
                lastDataHash = sha3(lastData);
                lastDataLength = lastData.length;
                lastData = lastData;

                // Log it.
                //DataRegistered(lastDataHash);
        }

        /*
         *  Call execution API
         */
        CallerPool callerPool;

        function getCallerPoolAddress() constant returns (address) {
                return address(callerPool);
        }

        // This number represents the constant gas cost of the addition
        // operations that occur in `doCall` that cannot be tracked with
        // msg.gas.
        uint constant EXTRA_CALL_GAS = 151098;

        // This number represents the overall overhead involved in executing a
        // scheduled call.
        uint constant CALL_OVERHEAD = 144982;

        event CallExecuted(address indexed executedBy, bytes32 indexed callKey);
        event CallAborted(address indexed executedBy, bytes32 indexed callKey, bytes18 reason);

        function doCall(bytes32 callKey) public {
                uint gasBefore = msg.gas;

                var call = key_to_calls[callKey];

                if (call.wasCalled) {
                        // The call has already been executed so don't do it again.
                        CallAborted(msg.sender, callKey, "ALREADY CALLED");
                        return;
                }

                if (call.isCancelled) {
                        // The call was cancelled so don't execute it.
                        CallAborted(msg.sender, callKey, "CANCELLED");
                        return;
                }

                if (call.contractAddress == 0x0) {
                        // This call key doesnt map to a registered call.
                        CallAborted(msg.sender, callKey, "UNKNOWN");
                        return;
                }

                if (block.number < call.targetBlock) {
                        // Target block hasnt happened yet.
                        CallAborted(msg.sender, callKey, "TOO EARLY");
                        return;
                }

                if (block.number > call.targetBlock + call.gracePeriod) {
                        // The blockchain has advanced passed the period where
                        // it was allowed to be called.
                        CallAborted(msg.sender, callKey, "TOO LATE");
                        return;
                }

                uint heldBalance = getCallMaxCost(callKey);

                if (accountBalances[call.scheduledBy] < heldBalance) {
                        // The scheduledBy's account balance is less than the
                        // current gasLimit and thus potentiall can't pay for
                        // the call.

                        // Mark it as called since it was.
                        call.wasCalled = true;
                        
                        // Log it.
                        CallAborted(msg.sender, callKey, "INSUFFICIENT_FUNDS");
                        return;
                }

                // Check if this caller is allowed to execute the call.
                if (callerPool.getPoolSize(callerPool.getActivePoolKey()) > 0) {
                        address poolCaller = callerPool.getDesignatedCaller(callKey, call.targetBlock, call.gracePeriod, block.number);
                        if (poolCaller != 0x0 && poolCaller != msg.sender) {
                                // This call was reserved for someone from the
                                // bonded pool of callers and can only be
                                // called by them during this block window.
                                CallAborted(msg.sender, callKey, "WRONG_CALLER");
                                return;
                        }

                        uint blockWindow = (block.number - call.targetBlock) / 4;
                        if (blockWindow > 0) {
                                // Someone missed their call so this caller
                                // gets to claim their bond for picking up
                                // their slack.
                                callerPool.awardMissedBlockBonus(msg.sender, callKey, call.targetBlock, call.gracePeriod);
                        }
                }

                // Log metadata about the call.
                call.gasPrice = tx.gasprice;
                call.executedBy = msg.sender;
                call.calledAtBlock = block.number;

                // Fetch the call data
                var data = getCallData(callKey);

                // During the call, we need to put enough funds to pay for the
                // call on hold to ensure they are available to pay the caller.
                _deductFunds(call.scheduledBy, heldBalance);

                // Mark whether the function call was successful.
                if (checkAuthorization(call.scheduledBy, call.contractAddress)) {
                        call.wasSuccessful = authorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);
                }
                else {
                        call.wasSuccessful = unauthorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);
                }

                // Add the held funds back into the scheduler's account.
                _addFunds(call.scheduledBy, heldBalance);

                // Mark the call as having been executed.
                call.wasCalled = true;

                // Log the call execution.
                CallExecuted(msg.sender, callKey);

                // Compute the scalar (0 - 200) for the fee.
                uint feeScalar = getCallFeeScalar(call.baseGasPrice, call.gasPrice);

                // Log how much gas this call used.  EXTRA_CALL_GAS is a fixed
                // amount that represents the gas usage of the commands that
                // happen after this line.
                call.gasUsed = (gasBefore - msg.gas + EXTRA_CALL_GAS);
                call.gasCost = call.gasUsed * call.gasPrice;

                // Now we need to pay the caller as well as keep fee.
                // callerPayout -> call cost + 1%
                // fee -> 1% of callerPayout
                call.payout = call.gasCost * feeScalar * 101 / 10000;
                call.fee = call.gasCost * feeScalar / 10000;

                _deductFunds(call.scheduledBy, call.payout + call.fee);

                _addFunds(msg.sender, call.payout);
                _addFunds(owner, call.fee);
        }

        function getCallMaxCost(bytes32 callKey) constant returns (uint) {
                /*
                 *  tx.gasprice * block.gaslimit
                 *  
                 */
                // call cost + 2%
                var call = key_to_calls[callKey];

                uint gasCost = tx.gasprice * block.gaslimit;
                uint feeScalar = getCallFeeScalar(call.baseGasPrice, tx.gasprice);

                return gasCost * feeScalar * 102 / 10000;
        }

        function getCallFeeScalar(uint baseGasPrice, uint gasPrice) constant returns (uint) {
                /*
                 *  Return a number between 0 - 200 to scale the fee based on
                 *  the gas price set for the calling transaction as compared
                 *  to the gas price of the scheduling transaction.
                 *
                 *  - number approaches zero as the transaction gas price goes
                 *  above the gas price recorded when the call was scheduled.
                 *
                 *  - the number approaches 200 as the transaction gas price
                 *  drops under the price recorded when the call was scheduled.
                 *
                 *  This encourages lower gas costs as the lower the gas price
                 *  for the executing transaction, the higher the payout to the
                 *  caller.
                 */
                if (gasPrice > baseGasPrice) {
                        return 100 * baseGasPrice / gasPrice;
                }
                else {
                        return 200 - 100 * baseGasPrice / (2 * baseGasPrice - gasPrice);
                }
        }

        /*
         *  Call Scheduling API
         */

        // The result of `sha()` so that we can validate that people aren't
        // looking up call data that failed to register.
        bytes32 constant emptyDataHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        function getCallKey(address scheduledBy, address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) constant returns (bytes32) {
                return sha3(scheduledBy, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);
        }

        // Ten minutes into the future.
        uint constant MAX_BLOCKS_IN_FUTURE = 40;

        event CallScheduled(bytes32 indexed callKey);
        //event CallRejected(bytes32 indexed callKey, bytes15 reason);

        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock) public {
                /*
                 *  Schedule call with gracePeriod defaulted to 255 and nonce
                 *  defaulted to 0.
                 */
                scheduleCall(contractAddress, abiSignature, dataHash, targetBlock, 255, 0);
        }

        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod) public {
                /*
                 *  Schedule call with nonce defaulted to 0.
                 */
                scheduleCall(contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, 0);
        }

        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) public {
                /*
                 * Primary API for scheduling a call.  Prior to calling this
                 * the data should already have been registered through the
                 * `registerData` API.
                 */
                bytes32 callKey = getCallKey(msg.sender, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);

                if (dataHash != emptyDataHash && hash_to_data[dataHash].length == 0) {
                        // Don't allow registering calls if the data hash has
                        // not actually been registered.  The only exception is
                        // the *emptyDataHash*.
                        //CallRejected(callKey, "NO_DATA");
                        return;
                }

                if (targetBlock < block.number + MAX_BLOCKS_IN_FUTURE) {
                        // Don't allow scheduling further than
                        // MAX_BLOCKS_IN_FUTURE
                        //CallRejected(callKey, "TOO_SOON");
                        return;
                }
                var call = key_to_calls[callKey];

                if (call.contractAddress != 0x0) {
                        //CallRejected(callKey, "DUPLICATE");
                        return;
                }

                if (gracePeriod < 16) {
                        //CallRejected(callKey, "GRACE_TOO_SHORT");
                        return;
                }

                lastCallKey = callKey;

                call.contractAddress = contractAddress;
                call.scheduledBy = msg.sender;
                call.nonce = nonce;
                call.abiSignature = abiSignature;
                call.dataHash = dataHash;
                call.targetBlock = targetBlock;
                call.gracePeriod = gracePeriod;
                call.baseGasPrice = tx.gasprice;

                // Put the call into the grove index.
                grove.insert(GROVE_INDEX_NAME, lastCallKey, int(call.targetBlock));

                CallScheduled(lastCallKey);
        }

        bytes32 constant GROVE_INDEX_NAME = "callTargetBlock";

        function getGroveAddress() constant returns (address) {
                return address(grove);
        }

        function getGroveIndexName() constant returns (bytes32) {
                return GROVE_INDEX_NAME;
        }

        function getGroveIndexId() constant returns (bytes32) {
                return grove.getIndexId(address(this), GROVE_INDEX_NAME);
        }

        //event CallCancelled(bytes32 indexed callKey);

        // Two minutes
        uint constant MIN_CANCEL_WINDOW = 8;

        function cancelCall(bytes32 callKey) public {
                var call = key_to_calls[callKey];
                if (call.scheduledBy != msg.sender) {
                        // Nobody but the scheduler can cancel a call.
                        return;
                }
                if (call.wasCalled) {
                        // No need to cancel a call that already was executed.
                        return;
                }
                if (call.targetBlock - MIN_CANCEL_WINDOW <= block.number) {
                        // Call cannot be cancelled this close to execution.
                        return;
                }
                call.isCancelled = true;
                //CallCancelled(callKey);
        }

        function __throw() internal {
                int[] x;
                x[1];
        }
}{% endblock contract_source %}


{% block contract_binary %}
======= Alarm =======
Binary: 
606060405260008054600160a060020a03191673fe9d4e5717ec0e16f8301240df5c3f7d3e9effef179055606061016e806100c3833901809050604051809103906000f060405160028054600160a060020a0319169290921790915561016e80610231833901809050604051809103906000f060405160038054600160a060020a03191692909217909155610eae8061039f833901809050604051809103906000f0600b8054600160a060020a0319169190911790556118ec8061124d6000396000f3606060405260008054600160a060020a0319163317905561014a806100246000396000f3606060405260e060020a6000350463e8b1d0f3811461001b575b005b60806020601f6044356004818101359283018490049093028401604052606082815261009e949335936024803594606494909101918190838280828437509495505050505050600080543373ffffffffffffffffffffffffffffffffffffffff9081169116146100b0576100b06000806001815481101561000257505080805250565b60408051918252519081900360200190f35b8373ffffffffffffffffffffffffffffffffffffffff168360e060020a9004836040518260e060020a028152600401808280519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156101295780820380516001836020036101000a031916815260200191505b509150506000604051808303816000876161da5a03f197965050505050505056606060405260008054600160a060020a0319163317905561014a806100246000396000f3606060405260e060020a6000350463e8b1d0f3811461001b575b005b60806020601f6044356004818101359283018490049093028401604052606082815261009e949335936024803594606494909101918190838280828437509495505050505050600080543373ffffffffffffffffffffffffffffffffffffffff9081169116146100b0576100b06000806001815481101561000257505080805250565b60408051918252519081900360200190f35b8373ffffffffffffffffffffffffffffffffffffffff168360e060020a9004836040518260e060020a028152600401808280519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156101295780820380516001836020036101000a031916815260200191505b509150506000604051808303816000876161da5a03f197965050505050505056606060405260008054600160a060020a03191633179055610e8a806100246000396000f3606060405236156100e55760e060020a600035046319f74e1f811461012957806323306ed614610147578063299179541461015257806350a3bd391461015e5780635ae348681461016a5780636595f73a14610175578063741b3c391461019057806384c92c9a146101985780638dd5e298146101ad578063910789c4146101bf5780639d12f0f5146101fc578063a6814e8e14610250578063aec918c71461025f578063b010d94a1461027f578063bc966ddc14610294578063c3daab961461029f578063c4afc3fb146102ae578063c861cd66146102c9578063e8543d0d146102e1575b6103265b61032833345b600160a060020a0382166000908152600160205260409020548082011015610359576103595b600080600181548110156100025750508052565b61032a6004356024355b60006000600083600014156108225761081a565b61032a5b3a45025b90565b61032661099333610286565b610326610957336101b4565b61032a61020061014f565b61032a6004356000818152600360205260409020545b919050565b6103266100e9565b61032a6004355b60006107f733610809610254565b61032a6004355b60006108928261019f565b61032a60043560028054829081101561000257506000527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace015481565b61032660043560243560443560643560006000600060006000600060006000600060009054906101000a9004600160a060020a0316600160a060020a031633600160a060020a03161415156104de57610576565b61032a5b600061079b43610266565b61032a6004355b600060006000600260005054600014156107335761072c565b61032a6004355b600061090682610809610254565b61032a61010061014f565b61032660043561037b3361019f565b61032a5b60006000600260005054600014156107ab576107a7565b61032a60043560016020526000908152604090205481565b61033c6004356024356044356064355b6000600060006000600060008887108061030f57508760ff16890187115b1561045657600095505b5050505050949350505050565b005b565b60408051918252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b600160a060020a03821660009081526001602052604090208054820190555050565b156103d657600160a060020a0333166000908152600160205260409020548111156103a8576103a8610115565b6103b061014b565b600160a060020a03331660009081526001602052604090205482900310156103d6575b50565b61040433825b600160a060020a0382166000908152600160205260409020548111156109bc576109bc610115565b604051600160a060020a03331690600090839082818181858883f1935050505015156103d35733600160a060020a03165a60405183906000818181858888f1935050505015156103d3576103d3610115565b61045f89610266565b945084600014156104735760009550610319565b60008581526003602052604090209350600460ff89811682900416935089880304915060028201839011156104ab5760009550610319565b508254808a069084908284018190069081101561000257600091825260209091200154600160a060020a03169550610319565b6104e78a610266565b60008181526003602052604090209098509650600460ff8a8116829004169350438b90030491506002820183901115610526576105358b8b8b8d6102f1565b60028754101561061857610576565b8a965090505b60ff89168a018611610576576105538b8b8b896102f1565b9350600160a060020a038481169082161480156105705750898614155b156105e5575b505050505050505050505050565b604080518d815243602082015280820183905290519196508991600160a060020a038f811692908816917f47d4e871a02baa58fd74fe0787c713589a0ce351d4c70ffe2d0f10353fab9fe59181900360600190a45b6004959095019461053b565b8b600160a060020a031684600160a060020a03161415610604576105d9565b610584848d5b6000600060006109df61014b565b600095505b8654861015610576578b600160a060020a03168787815481101561000257600091825260209091200154600160a060020a0316141561068857868754600189548901030681548110156100025760206000200154600160a060020a031694506106949050848d61060a565b6001959095019461061d565b604080518d815243602082015280820183905290519196508991600160a060020a038f811692908816917f47d4e871a02baa58fd74fe0787c713589a0ce351d4c70ffe2d0f10353fab9fe59181900360600190a46106f06102b2565b60001415610706576107065b6000610a256102b2565b610576846107126102b2565b600060008260001415610cab57610cab610115565b600092505b5050919050565b600091505b60025482101561072757600280548381036000190190811015610002576000919091527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace0154905083811161078f5780925061072c565b60019190910190610738565b905061014f565b600091505b5090565b60028054600019810190811015610002576000919091527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01549050438111156107a2578091506107a7565b8061080e575061080e336108096102b2565b610133565b905061018b565b600092505b505092915050565b600084815260036020526040812080549093501415610844576000925061081a565b5060005b81548110156108155784600160a060020a03168282815481101561000257600091825260209091200154600160a060020a0316141561088a576001925061081a565b600101610848565b1561089f5750600061018b565b6108a76102b2565b6000141580156108c257506101006108bd6102b2565b034310155b156108cf5750600061018b565b6108d761014b565b600160a060020a03831660009081526001602052604090205410156108fe5750600061018b565b50600161018b565b15156109145750600061018b565b61091c6102b2565b6000146108fe5761010061092e6102b2565b03431061093d5750600061018b565b610949826108096102b2565b15156108fe5750600061018b565b15610328576109646102b2565b60001415610974576109746106fc565b610328336109806102b2565b60008160001415610c1657610c16610115565b15610328576109a06102b2565b600014156109b0576109b06106fc565b610328336107126102b2565b600160a060020a0382166000908152600160205260409020805482900390555050565b600160a060020a038616600090815260016020526040902054909250905080821115610a09579050805b610a1385836103dc565b610a1d84836100ef565b81925061081a565b600014610a3457610a34610115565b50610200430160036000610a46610254565b81526020818101929092526040908101600090812084825260038452918120825481548183558284529490922090938101928215610aa55760005260206000209182015b82811115610aa5578254825591600101919060010190610a8a565b50610acb9291505b808211156107a7578054600160a060020a0319168155600101610aad565b5050610b188160008181526003602052604081209080805b8354811015610dd2578354604080514340815260208101849052815190819003909101902006925082811415610dd957610e82565b6002805460018101808355919082908015829011610b5957818360005260206000209182019101610b5991905b808211156107a75760008155600101610b45565b505060028054849350909150600019810190811015610002575080546000919091527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acd015550565b50505050828160018354038154811015610002575050815460008381526020812091909101600019018054600160a060020a0319169092179091556040518391600160a060020a038616917fa192e48a82f18ef1c93e722713426e5733e98d5b2858ba5c7457faf4a8297dab9190a35b505050565b610c208383610133565b15610c2a57610c11565b50600081815260036020526040902080546001810180835590829082908015829011610ba157818360005260206000209182019101610ba19190610b45565b505050505b6040518390600160a060020a038616907feee53013e70e8b24433023a137d553d5fc6a714de816654052b177b9806f35bf90600090a35b50505050565b610cb58484610133565b1515610cc057610ca5565b6000838152600360205260409020805490925060011415610d0a5760008281815481835581811511610d0557818360005260206000209182019101610d059190610b45565b505050505b5060005b8154811015610c6e5783600160a060020a03168282815481101561000257600091825260209091200154600160a060020a03161415610dca57816001835403815481101561000257906000526020600020900160009054906101000a9004600160a060020a031682828154811015610002576020600020018054600160a060020a031916909217909155508154600019810180845590839082908015829011610c6957818360005260206000209182019101610c699190610b45565b600101610d0e565b5050505050565b8381815481101561000257508054600082815260209020830154600160a060020a03169350849081101561000257906000526020600020900160009054906101000a9004600160a060020a0316848281548110156100025750602060002083018054600160a060020a03191690921790915550835482908590859081101561000257906000526020600020900160006101000a815481600160a060020a03021916908302179055505b600101610ae356606060405236156101d75760e060020a600035046303d6d7b6811461021a578063086ae9e41461024657806309c975df146102645780631145a20f1461028757806312d67c5f146102a85780631302188c146102b2578063234917d4146102bd5780632a472ae8146102da5780632e1a7d4d1461030157806332b212551461033157806334c19b93146103c257806335b28153146103e25780633664a0ea1461043057806352afbc331461043b57806353a0dc7d146104645780635539d400146104d757806360b831e5146104eb578063662fc8a01461051e578063685c234a146105325780636ff96d171461057f5780636ffc08961461059757806375428615146105be57806377b19cd51461064957806378bc6460146106675780638b37e6561461068457806394d2b21b146106aa57806394f3f81d146106be578063a152a2ba14610709578063a9743c681461071d578063aa4cc01f1461073a578063b0ac4c8c14610761578063b0f07e44146107d2578063cd06273414610817578063da0774ad14610841578063da2b861614610862578063e409865514610880578063f340fa011461089d578063f828c3fa146108ad578063f9f447eb146108cc578063fc300522146108e9578063fcf3691814610906575b6109ab6109ad33345b600160a060020a0382166000908152600160205260409020548082011015610a8c57610a8c5b600080600181548110156100025750508052565b6109ef6004355b60008181526006602081905260408220908101543a458102918491611639919061084b565b6109ef6004356000818152600660205260409020600801545b919050565b610a01600435600081815260066020526040902054600160a060020a031661025f565b6109ab60043560243560443560643560843561166885858585856000610451565b6109ef6008545b90565b6109ef6009546102af565b6109ef60043560008181526006602052604090206003015461025f565b6109ef6004356000818152600660205260409020600c015460c860020a900460ff1661025f565b6109ab600435600160a060020a033316600090815260016020526040902054819010610afb57610afe3382610b67565b6109ef60408051600080547fd2bbf6df00000000000000000000000000000000000000000000000000000000835230600160a060020a039081166004850152608860020a6e63616c6c546172676574426c6f636b02602485015293519193169163d2bbf6df916044828101926020929190829003018187876161da5a03f115610002575050506040515190506102af565b6109ef60043560008181526006602052604090206004015460ff1661025f565b6109ab60043560408051600160a060020a03838116606060020a9081028352339190911602601482015281519081900360280190206000908152600460205220805460ff1916600117905550565b6109ef6005546102af565b6109ab60043560243560443560643560843560a4355b6000600061166f3389898989898961047d565b6109ef60043560243560443560643560843560a43560c4355b60408051600160a060020a03988916606060020a90810282529790981690960260148801526028870194909452602c860192909252604c85015260ff1660f860020a02606c840152606d8301525190819003608d01902090565b610a01600354600160a060020a03166102af565b6109ab60043560008181526006602052604090206001810154600160a060020a0390811633919091161461184d57610aab565b610a01600b54600160a060020a03166102af565b6109ef6004356024355b60408051600160a060020a03848116606060020a9081028352908416026014820152815190819003602801902060009081526004602052205460ff165b92915050565b6109ef60043560016020526000908152604090205481565b6109ef6004356000818152600660205260409020600c015460d060020a900460ff1661025f565b610a1e6004355b6040805160208181018352600080835284815260068252838120600d01548152600a825283902080548451601f8201849004840281018401909552808552929392909183018282801561063d57820191906000526020600020905b81548152906001019060200180831161062057829003601f168201915b5050505050905061025f565b6109ef6004356000818152600660208190526040909120015461025f565b6109ef60043560008181526006602052604090206007015461025f565b610a01600435600081815260066020526040902060010154600160a060020a031661025f565b610a01600254600160a060020a03166102af565b6109ab60043560408051600160a060020a03838116606060020a9081028352339190911602601482015281519081900360280190206000908152600460205220805460ff1916905550565b610a01600054600160a060020a03166102af565b6109ef6004356000818152600660205260409020600a015461025f565b6109ef6004356000818152600660205260409020600c015460c060020a900460ff1661025f565b610a1e604080516020818101835260008252825160078054601f810184900484028301840190955284825292939092918301828280156107c657820191906000526020600020905b8154815290600101906020018083116107a957829003601f168201915b505050505090506102af565b6007805460031936018083556109ab9260009282908015829011610bd157601f016020900481601f01602090048360005260206000209182019101610bd19190610c5a565b6109ef6004356000818152600660205260409020600c015460a060020a900460e060020a0261025f565b6109ef6004356024355b60008282111561164d578183606402049050610579565b6109ef608860020a6e63616c6c546172676574426c6f636b026102af565b6109ef60043560008181526006602052604090206002015461025f565b6109ab600435610aaf81346101e0565b6109ab6004356024356044356064356116628484848460ff6000610451565b6109ef6004356000818152600660205260409020600d015461025f565b6109ef6004356000818152600660205260409020600b015461025f565b6109ab60043560006000600060006000602060405190810160405280600081526020015060005a888252600660205260408220600c810154919850965060c860020a900460ff1615610e1d57604080517f414c52454144592043414c4c4544000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a35b5050505050505050565b005b604080513481529051600160a060020a0333169182917f5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f629181900360200190a3565b60408051918252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b60405180806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f168015610a7e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b600160a060020a03821660009081526001602052604090208054820190555b5050565b80600160a060020a031633600160a060020a03167f5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62346040518082815260200191505060405180910390a35b50565b604051600160a060020a03331690600090839082818181858883f193505050501515610b8f5733600160a060020a03165a60405183906000818181858888f193505050501515610b8f57610b8f610206565b60018701549092506112fc90600160a060020a0316865b600160a060020a0382166000908152600160205260409020548111156118a9576118a9610206565b604080518281529051600160a060020a033316917f884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364919081900360200190a250565b50505060043611159050610c72575060005b600754811015610c7257600060048201368110156100025790013560f860020a900460f860020a026007600050828154811015610002579060005260206000209060209182820401919006601f036101000a81548160ff0219169060f860020a84040217905550600101610be3565b50610d3a9291505b80821115610c6e5760008155600101610c5a565b5090565b6007600050600a60005060006007600050604051808280548015610ccb57908552017fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688825b815481529060010190602001808311610cb7575b50509150506040518091039020815260200190815260200160002060005090805482805482825590600052602060002090601f01602090048101928215610c5257600052602060002091601f016020900482015b82811115610c52578254825591600101919060010190610d1f565b50506007600050604051808280548015610d8c57600091909152017fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688825b815481529060010190602001808311610d78575b5050604051908190039020600955505060078054600881905560008290526020601f8201047fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c6889081019190838215610e0c57600052602060002091601f016020900482015b82811115610e0c578254825591600101919060010190610df1565b50610e18929150610c5a565b505050565b600c86015460c060020a900460ff1615610e8457604080517f43414e43454c4c45440000000000000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b8554600160a060020a031660001415610eea57604080517f554e4b4e4f574e00000000000000000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b6003860154431015610f4957604080517f544f4f204541524c590000000000000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b6003860154600487015460ff1601431115610fb157604080517f544f4f204c415445000000000000000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b610fba88610221565b600187810154600160a060020a0316600090815260209190915260409020549095508590101561104f57600c8601805460c860020a60ff02191660c860020a179055604080517f494e53554646494349454e545f46554e44530000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b60408051600b547fa6814e8e0000000000000000000000000000000000000000000000000000000082529151600092600160a060020a031691636595f73a91839163a6814e8e916004828101926020929190829003018189876161da5a03f1156100025750506040805180517f6595f73a0000000000000000000000000000000000000000000000000000000082526004820152905160248281019350602092829003018187876161da5a03f115610002575050506040515111156112c65760408051600b54600389015460048a8101547fe8543d0d0000000000000000000000000000000000000000000000000000000085529084018d9052602484019190915260ff1660448301524360648301529151600160a060020a03929092169163e8543d0d9160848181019260209290919082900301816000876161da5a03f1156100025750505060405151935083600160a060020a03166000141580156111c8575033600160a060020a031684600160a060020a031614155b1561122057604080517f57524f4e475f43414c4c45520000000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b60048660030160005054430304925060008311156112c657604080516003880154600b5460048a8101547f9d12f0f5000000000000000000000000000000000000000000000000000000008552600160a060020a0333811692860192909252602485018e9052604485019390935260ff9290921660648401529251921691639d12f0f591608481810192600092909190829003018183876161da5a03f115610002575050505b3a6007870155600c8601805473ffffffffffffffffffffffffffffffffffffffff191633179055436002870155610b50886105c5565b8554600187015461131991600160a060020a03918216911661053c565b1561142a57600354600160a060020a031663e8b1d0f3620236565a038860000160009054906101000a9004600160a060020a031689600c0160149054906101000a900460e060020a02866040518560e060020a0281526004018084600160a060020a03168152602001838152602001806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156113e45780820380516001836020036101000a031916815260200191505b5094505050505060206040518083038160008887f11561000257505060405151600c8901805460d060020a60ff02191660d060020a909202919091179055506115319050565b600254600160a060020a031663e8b1d0f3620236565a038860000160009054906101000a9004600160a060020a031689600c0160149054906101000a900460e060020a02866040518560e060020a0281526004018084600160a060020a03168152602001838152602001806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156114f05780820380516001836020036101000a031916815260200191505b5094505050505060206040518083038160008887f11561000257505060405151600c8901805460d060020a60ff02191660d060020a90920291909117905550505b600186015461154990600160a060020a0316866101e0565b600c8601805460c860020a60ff02191660c860020a1790556040518890600160a060020a033316907fed1062ba7ed13514b41ef115d3c324f50dcd644da75ee5659e9ae97071774f1e90600090a3600686015460078701546115ab919061084b565b905062024e3a5a880301600887018190556007870154026009870181905561271090820260658102829004600a8901819055919004600b8801819055600188015461160392600160a060020a03919091169101610b67565b6116143387600a01600050546101e0565b6109a173d3cda913deb6f67967b99d67acdfa1712c29360187600b01600050546101e0565b612710920260660291909104949350505050565b818360020203836064020460c8039050610579565b50505050565b5050505050565b91507fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47086148015906116ad57506000868152600a6020526040812054145b156116b7576109a1565b602843018510156116c7576109a1565b50600081815260066020526040812080549091600160a060020a0391909116146116f0576109a1565b60108460ff161015611701576109a1565b6005828155815473ffffffffffffffffffffffffffffffffffffffff199081168a17835560018301805490911633179055818101849055600c8201805477ffffffff0000000000000000000000000000000000000000191660a060020a60e060020a8b0402179055600d8201879055600382018690556004828101805460ff1916871790553a6006840155600080549254604080517f870e5405000000000000000000000000000000000000000000000000000000008152608860020a6e63616c6c546172676574426c6f636b029481019490945260248401919091526044830189905251600160a060020a03939093169263870e5405926064818101939291829003018183876161da5a03f11561000257505060405160055491507f5ca1bad5a7f3ee229aa045a13d9936a9a5f7f70067a0e39bdb8a6c0086b1544c90600090a25050505050505050565b600c81015460c860020a900460ff161561186657610aab565b600381015443600719919091011161187d57610aab565b600c01805478ff000000000000000000000000000000000000000000000000191660c060020a17905550565b600160a060020a03821660009081526001602052604090208054829003905550505684b46e45ca3bd189c011a16ca05a10d3520bc4802b03a59efd78a568a20fedfe
Binary of the runtime part: 
606060405236156101d75760e060020a600035046303d6d7b6811461021a578063086ae9e41461024657806309c975df146102645780631145a20f1461028757806312d67c5f146102a85780631302188c146102b2578063234917d4146102bd5780632a472ae8146102da5780632e1a7d4d1461030157806332b212551461033157806334c19b93146103c257806335b28153146103e25780633664a0ea1461043057806352afbc331461043b57806353a0dc7d146104645780635539d400146104d757806360b831e5146104eb578063662fc8a01461051e578063685c234a146105325780636ff96d171461057f5780636ffc08961461059757806375428615146105be57806377600081815260066020526040902054600160a060020a031661025f565b6109ab60045b6109ef6008545b90565b6109ef6009546102af565b6109ef600435600081815260066909452602c860192909252604c85015260ff1660f860020a02606c840152606d8301525190819003608d01902090565b610a01600354600160a060020a03166102af565b6109ab600435f565b610a01600254600160a060020a03166102af565b6109ab60043560408051600160a060020a03838116606060020a908102835233919091160260148201528151908190036028019346101e0565b6109ab6004356024356044356064356116628484848460ff6000610451565b60190555b5050565b80600160a060020a031633600160a060020a03167f5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62346040518082815260200191505060405180910390a35b50565b942694bea4ce44661d9a8736c688825b815481529060010190602001808311610cb7000000000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b6003860154876161da5a03f1156100025750506040805180517f6595f73a00000000000000000000000000000000000000000000000000000000825260048201529051602482810193506020928290810192600092909190829003018183876161da5a03f115610002575050505b3a600787015565080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156114f05780820380516001836020036101000a031916815260200191505b5094505050505060206040518083038160008887f11561000257505060405151600c8901805460d060020a60ff02191660d060020a90920291909117905550505b600186015461154990600160a060020a0316866101e0565b600c8601805460c860020a60ff02191660c860020a1790556040518890600160565b600160a060020a03821660009081526001602052604090208054829003905550505684b46e45ca3bd189c011a16ca05a10d3520bc4802b03a59efd78a568a20fedfe

======= CallerPool =======
Binary: 
606060405260008054600160a060020a0319163317905565260409020545b919050565b6103266100e9565b61032a6004355b60006107f733610809610254565b61032a6004355b60006108928261019f565b61032a60043560028054829081101561000257506000527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace015481565b61032660043560243560443560643560006000600060006000600060006000600060009054906101000a9004600160a060020a0316600160a060020a031633600160a060020a03161415156160020a0333166000908152600160205260409020548111156103a8576103a8610115565604080518d815243602082015280820183905290519196508991600160a060020a038f811692908816917f47d4e871a02baa58fd74fe0787c713589a0ce351d4c70ffe2d0f10353fab9078f5780925061072c565b60019190910190610738565b905061014f565b600091505b5090001415610c1657610c16610115565b15610328576109a06102b2565b600014156109b0576109b06106fc565b610328336107126102b2565b600160a060020a038216600090815260016020f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acd015550565b50505050828160018354038154811015610002575050815460008381526020812091909101600019018054600160a060020a031916909217909120018054600160a060020a031916909217909155508154600019810180845590839082908015829011610c6957818360005260206000209182019101610c699190610b455652833345b600160a060020a0382166000908152600160205260409020548082011015610359576103595b600080600181548110156100025750508052565b61032a6004356024355b60044356064355b6000600060006000600060008887108061030f57508760ff16890187115b15526003602052604090209098509650600460ff8a8116829004169350438b9003049150600286102b2565b60001415610706576107065b6000610a256102b2565b610576846107126102b25604090205410156108fe5750600061018b565b50600161018b565b15156109145750600061018b565b61091c6102b2565b6000146108f5783546040805143408152602081018490528151908190039091019020069250857818360005260206000209182019101610d059190610b45565b505050505b5060005b8154811015610c6e5783600160a060020a03168282815481101561000257600091825260209091200154600160a060020a03161415610dca57816001835403815481101561000257906000526020600020900160009054906101000a9004600160a060020a031682828154811015610002576020600020018054600160a060020a031916909217909155508154600019810350463e8b1d0f3811461001b575b005b60806020601f6044356004818101359283018490049093028401604052606082815261009e9493359360248035946064949091019181908382808fffffffffffffffffffffffffffffffffffffff168360e060020a9004836040518260e060020a028152600401808280519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156101295780820380516001836020036101000a031916815260200191505b509150506000604051808303816000876161da5a03f197965050505050505056{% endblock %}
